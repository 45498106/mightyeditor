/*
 * License: MIT http://opensource.org/licenses/MIT
 * do not edit this file directly - as it will get updated automatically width MightyEditor update
 */
(function(global){
	"use strict";
	var data = null;
	
	if(global.mt && global.mt.data){
		data = global.mt.data;
	}
	
	global.mt = {
		
		SPRITE: 0,
		GROUP: 1,
		TEXT: 2,
		TILE_LAYER: 3,
		
		knownFonts: [
			"Arial",
			"Comic Sans MS",
			"Courier New",
			"Georgia",
			"Impact",
			"Times New Roman",
			"Trebuchet MS",
			"Verdana"
		],
 
		assets: {},
		objects: {},
	
		assetsPath: "assets",
		game: null,
	
		data: data,
		
		autoLoadFonts: true,
		
		init: function(game){
			this.game = game;
			this.game.load.crossOrigin = "anonymous";
			this.game.load.script("hacks", "js/lib/phaserHacks.js");
		},
 
		setBackgroundColor: function(appendToBody){
			
			if(this.data.map.backgroundColor){
				var tmp = this.data.map.backgroundColor.substring(1);
				var bg = parseInt(tmp, 16);
				
				if(this.game.stage.backgroundColor != bg){
					this.game.stage.setBackgroundColor(bg);
				}
			}
			
			if(appendToBody){
				document.body.style.backgroundColor = this.data.map.backgroundColor;
			}
		},
 
		// preload all assets
		preload: function(){
			this._loadAssets(this.data.assets.contents, this.assets, "");
		},
		
		// load assets for seperate object group
		loadGroup: function(name){
			var toLoad = {};
			var group = this.getObjectGroupByName(name);
			if(!group){
				console.error("failed to load group: ", name);
				return;
			}
			this._collectAssets(group, toLoad);
			this._loadAssetBuffer(toLoad);
		},
		
		// create full map
		createAll: function(){
			this._loadObjects(this.data.objects.contents, this.objects, "", null, true);
		},
		
		// create seperate group
		create: function(name, parent){
			parent = parent || this.game.world;
			var group = this.getObjectGroupByName(name);
			if(!group){
				console.error("failed to find the group: ", name);
				return;
			}
			
			var objects = {};
			
			this._add(group, objects, "", parent);
			
			return objects[name];
		},
		
		createPack: function(name, pack, parent){
			pack = pack || {};
			parent = parent || this.game.world;
			
			var group = this.getObjectGroupByName(name);
			if(!group){
				console.error("failed to find the group: ", name);
				return;
			}
			this._add(group, pack, "", parent);
			pack.movies = this.createMovies(pack);
			return pack;
		},
		createGroup: function(name, parent){
			console.warn('mt.createGroup is deprecated. Use mt.create("'+name+'") instead');
			return mt.create(name, parent);
		},
		
		// create slope map for tilelayer
		createSlopeMap: function(layer){
			var map = {};
			var data = layer.layer.data;
			var i=0, j=0;
			
			for( ;i<data.length; i++){
				for(j=0; j<data[i].length; j++){
					if(data[i][j].index > 0){
						map[i*data[i].length + j] = data[i][j].index;
					}
				}
			}
			return map;
		},
		
		// create movie
		createMovies: function(pack){
			var that = this;
			
			var movie, fps, out = {},
				data = pack.data,
				object = pack.self,
				lf;
			
			for(var key in data.movies){
				movie = data.movies[key];
				fps = movie.info.fps;
				
				lf = this.getLastFrame(pack.data, key);
				console.log("last frame:", lf);
				
				out[key] = this.createMovie(pack, key, fps, lf * 1000/fps);
				out[key+"Flip"] = this.createMovie(pack, key, fps, lf * 1000/fps, true);
			}
			
			return out;
		},
		
		createMovie: function(pack, name, fps, length, flip){
			fps = fps || movie.info.fps;
			
			var children = [];
			
			var object = pack.self,
				tween = this.game.add.tween(object),
				child, children,
				data = pack.data;
			
			if(data.contents){
				for(var key in pack.children){
					child = pack.children[key];
					this.createChildMovies(child, name, fps, length, children, flip);
				}
			}
			
			
			var movie = data.movies[name];
			var frames = movie.frames;
			var s = frames[0];
			var e = frames[frames.length - 1];
			var f = (flip ? -1 : 1);
			
			tween.onStart.add(function(){
				console.log("start", data.name);
				if(s){
					object.x = s.x*f;
					object.y = s.y;
					object.angle = s.angle*f;
					object.alpha = s.alpha;
					if(s.scaleX){
						object.scaleX = s.scaleX*f;
					}
					if(s.frame){
						object.frame = s.frame;
					}
				}
				if(!children){
					return;
				}
				
				var cs, co, ct;
				for(var i=0; i<children.length; i++){
					cs = children[i].startPos;
					co = children[i].object;
					ct = children[i].tween
					co.x = cs.x*f;
					co.y = cs.y;
					co.angle = cs.angle*f;
					co.alpha = cs.alpha;
					
					if(!cs.scaleX){
						cs.scaleX = co.scale.x;
					}
					co.scaleX = cs.scaleX * f;
					
					
					children[i].tween.pendingDelete = false;
					children[i].tween.resume();
					children[i].tween.start();
				}
			});
			
			
			tween.onComplete.add(function(){
				if(!children){
					return;
				}
				console.log("completed");
				for(var i=0; i<children.length; i++){
					//children[i].tween.stop();
				}
			});
			
			if(tween.onStop){
				tween.onStop.add(function(){
					console.log("stopped");
					for(var i=0; i<children.length; i++){
						children[i].tween = children[i].tween.stop();
					}
				});
			}
			
			
			var timeToGo = 0, kf, 
				oneFrame = 1000/fps,
				lastFrame = 0;
			
			var tmp = tween;
			var lf = s;
			for(var i=1; i<frames.length; i++){
				kf = frames[i];
				timeToGo = kf.keyframe*oneFrame;
				tmp = tmp.to(this._mkDiff(lf, kf), timeToGo - lastFrame);
				lf = kf;
				lastFrame = timeToGo;
			}
			
			if(timeToGo < length && e){
				tmp.to({x: e.x}, length - timeToGo + oneFrame);
			}
			
			
			
			return tmp;
		},
		
		createChildMovies: function(pack, name, fps, length, children, flip){
			fps = fps || movie.info.fps;
			var object = pack.self,
				tween = this.game.add.tween(object),
				child, children,
				data = pack.data;
			
			if(data.contents){
				for(var key in pack.children){
					child = pack.children[key];
					this.createChildMovies(child, name, fps, length, children, flip);
				}
			}
			
			
			var movie = data.movies[name];
			var frames = movie.frames;
			var s = frames[0];
			var e = frames[frames.length - 1];
			
			var timeToGo = 0, kf, 
				oneFrame = 1000/fps,
				lastFrame = 0;
			
			var tmp = tween;
			var lf = s;
			
			/*tmp = tween.from({
				x: s.x,
				y: s.y,
				alpha: s.alpha,
				angle: s.angle
			});*/
			
			for(var i=1; i<frames.length; i++){
				kf = frames[i];
				timeToGo = kf.keyframe*oneFrame;
				tmp = tmp.to(this._mkDiff(lf, kf, flip), timeToGo - lastFrame);
				lf = kf;
				lastFrame = timeToGo;
			}
			
			tween.name = data.name;
			
			children.push({tween: tween, startPos: s, object: object});
		},
 
		getLastFrame: function(data, name, len){
			len = len || 0;
			
			var t = 0;
			var frames = data.movies[name].frames;
			var lf = frames.length ? frames[frames.length - 1].keyframe : 0;
			var tmp = 0;
			
			if(data.contents){
				for(var i=0; i<data.contents.length; i++){
					tmp = this.getLastFrame(data.contents[i], name);
					if(tmp > lf){
						lf = tmp;
					}
				}
			}
			
			
			return lf;
		},
 
		_mkDiff: function(o1, o2, flip){
			var out = {};
			var f = (flip ? -1 : 1);
			for(var i in o1){
				if(typeof o1[i] === "object"){
					continue;
				}
				if(o1[i] === void(0)){
					continue;
				}
				if(o1[i] != o2[i]){
					if(i == "x" || i == "angle" || i == "scaleX"){
						out[i] = o2[i]*f;
					}
					else{
						out[i] = o2[i];
					}
				}
			}
			for(var i in o2){
				if(typeof o2[i] === "object"){
					continue;
				}
				if(o1[i] === void(0)){
					continue;
				}
				if(o1[i] != o2[i]){
					if(i == "x" || i == "angle" || i == "scaleX"){
						out[i] = o2[i]*f;
					}
					else{
						out[i] = o2[i];
					}
				}
			}
			return out;
		},
		
		_mk_scale: function(diff){
			var out = {};
			if(diff.scaleX != void(0)){
				out.x = diff.scaleX;
			}
			if(diff.scaleY != void(0)){
				out.y = diff.scaleY;
			}
			return out;
		},
		_mk_anchor: function(diff){
			var out = {};
			if(diff.anchorX != void(0)){
				out.x = diff.anchorX;
			}
			if(diff.anchorX != void(0)){
				out.y = diff.anchorY;
			}
			return out;
		},
 
		getObjectData: function(name, container){
			if(typeof name == "object"){
				name = name.name;
			}
			
			container = container || this.data.objects;
			
			if(container.contents){
				for(var i=0; i<container.contents.length; i++){
					if(container.contents[i].contents){
						this.getObjectData(name, container.contents[i]);
					}
					else{
						if(container.contents[i].name == name){
							return container.contents[i];
						}
					}
				}
			}
			if(container.name == name){
				return container;
			}
		},
 
		getAssetPath: function(asset){
			return this.assetsPath + asset.fullPath;
		},
		
		getObjectGroupByName: function(name, container){
			container = container || this.data.objects.contents;
			var ret;
			for(var i = 0; i < container.length; i++){
				if(container[i].name == name){
					return container[i];
				}
				if(container[i].contents){
					ret = this.getObjectGroupByName(name, container[i].contents);
					if(ret){
						return ret;
					}
				}
			}
		},
		
		getAssetByName: function(name, container){
			container = container || this.data.assets.contents;
			for(var i in container){
				if(container[i].name == name){
					return container[i];
				}
				if(container[i].contents){
					ret = this.getAssetById(id, container[i].contents);
					if(ret){
						return ret;
					}
				}
			}
			
			return ret;
		},
		
		getAssetById: function(id, container){
			container = container || this.data.assets.contents;
			var ret = null;
			
			for(var i in container){
				if(container[i].id == id){
					return container[i];
				}
				if(container[i].contents){
					ret = this.getAssetById(id, container[i].contents);
					if(ret){
						return ret;
					}
				}
			}
			
			return ret;
		},
		
		getObjectByName: function(name, container){
			container = container || this.data.objects.contents;
			for(var i in container){
				if(container[i].name == name){
					return container[i];
				}
				if(container[i].contents){
					ret = this.getObjectById(id, container[i].contents);
					if(ret){
						return ret;
					}
				}
			}
			
			return ret;
		},
 
		isKnownFontFamily: function(font){
			for(var i=0; i<this.knownFonts.length; i++){
				if(this.knownFonts[i] == font){
					return true
				}
			}
			return false;
		},
		
		loadFont: function(font, cb){
			
			var fontUrl = font.replace(/ /gi, "+");
			var link = document.createElement("link");
			link.setAttribute("rel", "stylesheet");
			link.setAttribute("type", "text/css");
			
			var span = document.createElement("span");
			span.style.position = "absolute";
			span.style.top = span.style.left = 0;
			span.style.zIndex = -1;
			
			span.style.fontFamily = font;
			span.innerHTML = "ignore moi";
			span.style.visibility = "hidden";
			document.body.appendChild(span);
			
			link.onload = function(e){
				
				window.setTimeout(function(){
					document.body.removeChild(span);
				}, 1000);
				window.setTimeout(function(){
					cb(font);
				}, 300);
			};
			
			link.href="//fonts.googleapis.com/css?family="+fontUrl;
			
			document.head.appendChild(link);
		},
		
		getFontFamily: function(font){
			if(!this.autoLoadFonts){
				return;
			}
			var span = document.createElement("span");
			span.style.font = font;
			
			var fontFamily = span.style.fontFamily.replace(/'/gi, '');
			
			if(this.isKnownFontFamily(fontFamily)){
				return;
			}
			var that = this;
			this._fontsToLoad++;
			this.loadFont(fontFamily, function(){
				that._fontsToLoad--;
				
				if(that._fontsToLoad == 0){
					//clean up height cache
					PIXI.Text.heightCache = {};
					that._markDirty();
				}
			});
			return;
		},
		
		physics: {
			ninja: {
				enableTileLayer: function (layer) {
					layer = layer.layer;
					for (var y = 0, h = layer.height; y < h; y++){
						for (var x = 0, w = layer.width; x < w; x++){
							var tile = layer.data[y][x];
							if (tile && tile.index > 0){
								var body = new Phaser.Physics.Ninja.Body(this, null, 3, tile.index, 0, tile.worldX + tile.centerX, tile.worldY + tile.centerY, tile.width, tile.height);
								layer.bodies.push(body);
							}
						}
					}
					return layer.bodies;
				}
			}
		},
 
 
		/* private stuff */
		_fontsToLoad: 0,
		_loadAssetBuffer: function(buffer){
			var container;
			var asset = null;
			for(var i in buffer){
				asset = buffer[i];
				
				container = this._getAssetContainer(asset);
				this._addAsset(asset, container);
			}
		},
 
		_getAssetContainer: function(asset){
			var cont = this.assets;
			var path = asset.fullPath.split("/");
			path.shift();
			for(var i=0; i<path.length-1; i++){
				cont[path[i]] = cont[path[i]] || {};
				cont = cont[path[i]];
			}
			return cont;
		},
 
		_getObjectContainer: function(object){
			var cont = this.assets;
			var path = asset.fullPath.split("/");
			path.shift();
			for(var i=0; i<path.length-1; i++){
				cont[path[i]] = cont[path[i]] || {};
				cont = cont[path[i]];
			}
			return cont;
		},
 
		_collectAssets: function(group, buffer){
			var id, object, asset;
			for(var i=0; i<group.contents.length; i++){
				object = group.contents[i];
				if(object.contents){
					this.collectAssets(object);
				}
				else{
					id = object.assetId;
					asset = this.getAssetById(id);
					if(asset){
						buffer[id] = asset;
					}
				}
			}
		},
 
		_loadAssets: function(data, container){
			var asset = null;
			
			for(var i = 0, l = data.length; i<l; i++){
				asset = data[i];
				if(asset.contents && asset.contents.length){
					if(container[asset.name] === void(0)){
						container[asset.name] = {};
					}
					this._loadAssets(asset.contents, container[asset.name]);
				}
				else{
					this._addAsset(asset, container);
				}
			}
		},
	
		_addAsset: function(asset, container){
			var path = this.assetsPath + asset.fullPath;
			var that = this;
			if(!asset.key){
				return;
			}
			// is already loaded ?
			if(container[asset.name]){
				return;
			}
			
			if(asset.atlas){
				this.game.load.atlas(asset.key, this.assetsPath + asset.fullPath, this.assetsPath + "/" + asset.atlas);
			}
			else if(asset.width != asset.frameWidth || asset.height != asset.frameHeight){
				this.game.load.spritesheet(asset.key, this.assetsPath + asset.fullPath, asset.frameWidth, asset.frameHeight, asset.frameMax, asset.margin, asset.spacing);
			}
			else{
				this.game.load.image(asset.key, this.assetsPath + asset.fullPath);
			}
			
			
			Object.defineProperty(container, asset.name, {
				get : function(){ 
					return asset;
				},
				enumerable: true
			});
			
		},
		
		_loadObjects: function(data, container, path, group, keepVisibility){
			group = group || this.game.world;
			path = path !== "" ? "." + path : path;
			
			
			
			for(var i = data.length - 1; i > -1; i--){
				container[data[i].name] = {};
				this._add(data[i], container[data[i].name], path, group, data, keepVisibility);
			}
			return container;
		},
		
		_add: function(object, container, path, group, parent, keepVisibility){
			var createdObject = null;
			
			if(object.type == this.GROUP){
				createdObject = this._addGroup(object, container);
				
				if(object.physics && object.physics.enable){
					createdObject.enableBody = true;
				}
				group.add(createdObject);
				
				
				container.self = createdObject;
				container.children = {};
				
				
				this._updateCommonProperties(object, createdObject, keepVisibility);
				this._loadObjects(object.contents, container.children, path + object.name, createdObject);
				
			}
			else{
				
				if(object.type == this.TEXT){
					createdObject = this._addText(object, container, group);
				}
				else if(object.type == this.TILE_LAYER){
					createdObject = this._addTileLayer(object, container, group);
					if(object.physics && object.physics.enable){
						createdObject.map.setCollisionByExclusion([-1]);
					}
				}
				else{
					createdObject = this._addObject(object, container, group);
					this.addPhysics(object, createdObject, container.data);
				}
				
				this._updateCommonProperties(object, createdObject, keepVisibility);
				
				if(object.contents){
					container.self = createdObject;
					container.children = {};
					this._loadObjects(object.contents, container.children, path + object.name, createdObject);
				}
			}
			
			if(!container.hasOwnProperty("data")){
				container.data = object;
			}
			
			container.self = createdObject;
		},
		
		addPhysics: function(tpl, sprite, parent){
			
			
			var p = tpl.physics;
			if(!p || !p.enable){
				if(parent && parent.physics && parent.physics.enable){
					p = parent.physics;
				}
			}
			if(p && p.enable){
				this.game.physics.arcade.enable(sprite);
				
				sprite.body.allowGravity = p.gravity.allow;
				sprite.body.gravity.x = p.gravity.x;
				sprite.body.gravity.y = p.gravity.y;
				
				sprite.body.immovable = p.immovable;
				
				sprite.body.bounce = p.bounce
				
				sprite.body.maxAngular = p.rotation.maxAngular;
				sprite.body.allowRotation = p.rotation.allowRotation;
				
				sprite.body.maxVelocity = p.maxVelocity;
				
				sprite.body.mass = p.mass;
				sprite.body.collideWorldBounds = p.collideWorldBounds;
				
				
				
				var w = sprite.width;
				var h = sprite.height;
				if(p.size.width > 0){
					w = p.size.width;
				}
				if(p.size.height > 0){
					h = p.size.height;
				}
				
				sprite.body.setSize(w, h, p.size.offsetX, p.size.offsetY);
			}
			
			
		},
 
		_addGroup: function(object){
			var group = this.game.add.group();

			group.x = object.x;
			group.y = object.y;
			group.fixedToCamera = !!object.fixedToCamera;
			
			if(object.angle){
				group.angle = object.angle;
			}
			group.alpha = object.alpha || 1;
			
			return group;
		},
		
		_addText: function(object, container, group){
			this.getFontFamily(object.style.font);
			
			group = group || this.game.world;
			var t = this.game.add.text(object.x, object.y, object.text || object.name, object.style);
			group.add(t);
			return t;
		},
		
		_addTileLayer: function(object, container, group){
			group = group || this.game.world;
			var map = this.game.add.tilemap(null, object.tileWidth, object.tileHeight, object.widthInTiles, object.heightInTiles);
			
			var tl = map.createBlankLayer(object.name, object.widthInTiles, object.heightInTiles, object.tileWidth, object.tileHeight);
			
			var nextId = 0;
			var im = null;
			var asset = "";
			for(var i=0; i<object.images.length; i++){
				asset = this.getAssetById(object.images[i]);
				
				if(asset){
					im = map.addTilesetImage(asset.key, asset.key, asset.frameWidth, asset.frameHeight, asset.margin, asset.spacing, nextId);
					nextId += im.total;
				}
				else{
					console.warn("cannot find image", object.images[i]);
				}
			}
			
			var tiles = object.tiles;
			var tile = null;
			for(var y in tiles){
				for(var x in tiles[y]){
					tile = map.putTile(tiles[y][x], x, y, tl);
				}
			}
			tl.fixedToCamera = object.isFixedToCamera;
			return tl;
		},
		
		_addObject: function(object, container, group){
			
			var sp = null;
			group = group || this.game.world;
			
			if(group.type == Phaser.GROUP){
				sp = group.create(object.x, object.y, object.assetKey);
			}
			else{
				sp = this.game.add.sprite(object.x, object.y, object.assetKey);
				
				this.game.world.removeChild(sp);
				group.addChild(sp);
			}
			
			
			var frameData = this.game.cache.getFrameData(object.assetKey);
			
			if(frameData){
				var arr = [];
				for(var i=0; i<frameData.total; i++){
					arr.push(i);
				}
				sp.animations.add("default", arr, (object.fps !== void(0) ? object.fps : 10) , false);
				sp.frame = object.frame;
			}
			return sp;
		},
 
		_updateCommonProperties: function(template, object, keepVisibility){
			
			if(template.angle){
				object.angle = template.angle;
			}
			
			if(template.type !== mt.GROUP && object.type != Phaser.GROUP){
				object.anchor.x = template.anchorX;
				object.anchor.y = template.anchorY;
				if(template.scaleX != void(0)){
					object.scale.x = template.scaleX;
					object.scale.y = template.scaleY;
				}
			}
			
			object.x = template.x;
			object.y = template.y;
			object.alpha = template.alpha || 1;
			
			if(keepVisibility){
				object.visible = template.isVisible;
			}
		},
		
		//mark all texts dirty to force redraw
		_markDirty: function(group){
			group = group || game.world.children;
			
			var child = null;
			for(var i=0; i<group.length; i++){
				child = group[i];
				
				if(child.type == Phaser.TEXT){
					child.dirty = true;
					continue;
				}
				
				if(child.type == Phaser.GROUP){
					this.markDirty(child.children);
				}
			}
		}
 
	};

})(typeof window == "undefined" ? global : window);
